# 788. 旋转数字

我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 `N`, 计算从 `1` 到 `N` 中有多少个数 X 是好数？

```
示例:
输入: 10
输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。

```

**注意:**

- N 的取值范围是 `[1, 10000]`。

## 解决方案

> 定义了一个长度为N+1的一维布尔型DP数组，其中dp[i]表示数字i的三种状态，0表示数字i翻转后不合法，1表示数字i翻转后和原数相同，2表示数字i翻转后形成一个不同的数字。那么根据题目中的定义可知，只有当dp[i]=2的时候才是好数字。那么下面来看状态转移方程吧，我们知道如果数字只有1位的话，那么判断起来很简单，如果是0，1，和8中的一个，那么dp[i]=1，如果是2，5，6，和9中的一个，那么dp[i]=2，并且结果res自增1。如果是剩下的三个数字3，4，7中的一个不用更新，因为dp数组初始化就为0。下面来看数字i大于10的情况，非常的经典，dp[i] 的值其实可以从 dp[i/10] 和 dp[i%10] 这两个状态值转移而来，由于我们更新的顺序是从小到大，所以当要更新dp[i]的时候，dp[i/10] 和 dp[i%10] 这两个状态值已经算过了。为啥dp[i] 的值是由这两个状态值决定的呢？因为每个数字都是相互独立的翻转，比如四位数字abcd，可以拆分为三位数abc，和个位数d，如果abc翻转后仍是abc，d翻转后仍是d，说明abcd翻转后仍是abcd，所以dp[i]=1，只要其中有一个大于1了，另外一个至少是1的话，那么说明可以翻转成不同的数字，dp[i]=2，并且结果res自增1.

参见代码如下：

```c++
class Solution {
public:
    int rotatedDigits(int N) {
        int res = 0;
        vector<int> dp(N + 1);   
        for (int i = 0; i <= N; ++i) {
            if (i < 10) {
                if (i == 0 || i == 1 || i == 8) dp[i] = 1;
                else if (i == 2 || i == 5 || i == 6 || i == 9) {
                    dp[i] = 2; ++res;
                }
            } else {
                int a = dp[i / 10], b = dp[i % 10];
                if (a == 1 && b == 1) dp[i] = 1;
                else if (a >= 1 && b >= 1) {
                    dp[i] = 2; ++res;
                }
            }
        }
        return res;
    }
};
```

