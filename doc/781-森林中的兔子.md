## 781. 森林中的兔子

森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 `answers` 数组里。

返回森林中兔子的最少数量。

```
示例:
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 "2" 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

输入: answers = [10, 10, 10]
输出: 11

输入: answers = []
输出: 0

```

**说明:**

1. `answers` 的长度最大为`1000`。
2. `answers[i]` 是在 `[0, 999]` 范围内的整数。

## 解决方案

可以使用一个HashMap来建立某种颜色兔子的总个数和在数组中还允许出现的个数之间的映射，然后我们遍历数组中的每个兔子，如果该兔子回答了x个，若该颜色兔子的总个数x+1不在HashMap中，或者映射为0了，我们将这x+1个兔子加入结果res中，然后将其映射值设为x，表示在数组中还允许出现x个也回答x的兔子；否则的话，将映射值自减1即可

```c++
class Solution {
public:
    int numRabbits(vector<int>& answers) {
        int res = 0;
        unordered_map<int, int> m;      
        for (int ans : answers) {
            if (!m.count(ans + 1) || m[ans + 1] == 0) {
                res += ans + 1;
                m[ans + 1] = ans;
            } else {
                --m[ans + 1];
            }
        }
        return res;
    }
};
```

下面这种思路也很巧妙，是先统计出不在数组中的兔子的个数，然后再加上回答问题的兔子数。我们使用一个长度为1000的数字代替HashMap，因为题目中限定了最多1000个兔子回答问题，然后我们对于每个回答x的兔子，将 cnt[x] 的值自增1，然后对 x+1 取余，那么余数就是总数为 x+1 的兔子中在数组中出现的个数，所以我们之后用 x+1 减去这个余数，就是不在数组中的兔子的个数。那么你可能会怀疑，当余数为0了，会不会漏掉了兔子啊，答案是不会的，因为我们最终要加上数组中的兔子个数，如果对 x+1 取余为0了，说明这 x+1 个兔子都在数组中出现了，所以我们不会漏掉任何兔子，参见代码如下：

```c++
class Solution {
public:
    int numRabbits(vector<int>& answers) {
        int res = 0;
        vector<int> cnt(1000, 0); 
        for (int ans : answers) cnt[ans] = (cnt[ans] + 1) % (ans + 1);
        for (int i = 0; i < 1000; ++i) {
            if (cnt[i] != 0) res += i + 1 - cnt[i];
        }
        return res + answers.size();
    }
};
```

